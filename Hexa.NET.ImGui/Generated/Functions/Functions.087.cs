// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.ImGui
{
	public unsafe partial class ImGui
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(ref Vector2 pOut, string text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(ref Vector2 pOut, string text, ref byte textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(ref Vector2 pOut, string text, ref byte textEnd, float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)ptextEnd, (byte)(0), wrapWidth);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(ref Vector2 pOut, string text, ReadOnlySpan<byte> textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(ref Vector2 pOut, string text, ReadOnlySpan<byte> textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(ref Vector2 pOut, string text, ReadOnlySpan<byte> textEnd)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)ptextEnd, (byte)(0), (float)(-1.0f));
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(ref Vector2 pOut, string text, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative((Vector2*)ppOut, pStr0, (byte*)ptextEnd, (byte)(0), wrapWidth);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, byte* textEnd, float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, textEnd, (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				CalcTextSizeNative(pOut, (byte*)ptext, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, byte* textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, byte* textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, byte* textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, textEnd, (byte)(0), wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, (byte*)(default), hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, byte* text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, byte* text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, byte* text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, byte* text, ReadOnlySpan<byte> textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, byte* text, ReadOnlySpan<byte> textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, byte* text, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				CalcTextSizeNative(pOut, text, (byte*)ptextEnd, (byte)(0), wrapWidth);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, byte* text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, byte* text, string textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, byte* text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			CalcTextSizeNative(pOut, text, pStr0, (byte)(0), wrapWidth);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, string textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, string textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			CalcTextSizeNative(pOut, pStr0, pStr1, (byte)(0), wrapWidth);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, ReadOnlySpan<byte> textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, ReadOnlySpan<byte> textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative(pOut, (byte*)ptext, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, string textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = &text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative(pOut, (byte*)ptext, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ref byte text, string textEnd, float wrapWidth)
		{
			fixed (byte* ptext = &text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative(pOut, (byte*)ptext, pStr0, (byte)(0), wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, ref byte textEnd, float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					CalcTextSizeNative(pOut, (byte*)ptext, (byte*)ptextEnd, (byte)(0), wrapWidth);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, string textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative(pOut, (byte*)ptext, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, string textEnd, bool hideTextAfterDoubleHash)
		{
			fixed (byte* ptext = text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative(pOut, (byte*)ptext, pStr0, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, ReadOnlySpan<byte> text, string textEnd, float wrapWidth)
		{
			fixed (byte* ptext = text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				CalcTextSizeNative(pOut, (byte*)ptext, pStr0, (byte)(0), wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, ref byte textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, pStr0, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, ref byte textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, pStr0, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, ref byte textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				CalcTextSizeNative(pOut, pStr0, (byte*)ptextEnd, (byte)(0), wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, ReadOnlySpan<byte> textEnd, bool hideTextAfterDoubleHash, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				CalcTextSizeNative(pOut, pStr0, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, ReadOnlySpan<byte> textEnd, bool hideTextAfterDoubleHash)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				CalcTextSizeNative(pOut, pStr0, (byte*)ptextEnd, hideTextAfterDoubleHash ? (byte)1 : (byte)0, (float)(-1.0f));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void CalcTextSize(Vector2* pOut, string text, ReadOnlySpan<byte> textEnd, float wrapWidth)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				CalcTextSizeNative(pOut, pStr0, (byte*)ptextEnd, (byte)(0), wrapWidth);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorConvertU32ToFloat4Native(Vector4* pOut, uint input)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector4*, uint, void>)funcTable[366])(pOut, input);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)funcTable[366])((nint)pOut, input);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static Vector4 ColorConvertU32ToFloat4(uint input)
		{
			Vector4 ret;
			ColorConvertU32ToFloat4Native(&ret, input);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertU32ToFloat4(Vector4* pOut, uint input)
		{
			ColorConvertU32ToFloat4Native(pOut, input);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertU32ToFloat4(ref Vector4 pOut, uint input)
		{
			fixed (Vector4* ppOut = &pOut)
			{
				ColorConvertU32ToFloat4Native((Vector4*)ppOut, input);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint ColorConvertFloat4ToU32Native(Vector4 input)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector4, uint>)funcTable[367])(input);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<Vector4, uint>)funcTable[367])(input);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static uint ColorConvertFloat4ToU32(Vector4 input)
		{
			uint ret = ColorConvertFloat4ToU32Native(input);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorConvertRGBtoHSVNative(float r, float g, float b, float* outH, float* outS, float* outV)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float*, float*, float*, void>)funcTable[368])(r, g, b, outH, outS, outV);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, nint, nint, nint, void>)funcTable[368])(r, g, b, (nint)outH, (nint)outS, (nint)outV);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, float* outS, float* outV)
		{
			ColorConvertRGBtoHSVNative(r, g, b, outH, outS, outV);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, float* outS, float* outV)
		{
			fixed (float* poutH = &outH)
			{
				ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, outS, outV);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, ref float outS, float* outV)
		{
			fixed (float* poutS = &outS)
			{
				ColorConvertRGBtoHSVNative(r, g, b, outH, (float*)poutS, outV);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, ref float outS, float* outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, (float*)poutS, outV);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, float* outS, ref float outV)
		{
			fixed (float* poutV = &outV)
			{
				ColorConvertRGBtoHSVNative(r, g, b, outH, outS, (float*)poutV);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, float* outS, ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutV = &outV)
				{
					ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, outS, (float*)poutV);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertRGBtoHSV(float r, float g, float b, float* outH, ref float outS, ref float outV)
		{
			fixed (float* poutS = &outS)
			{
				fixed (float* poutV = &outV)
				{
					ColorConvertRGBtoHSVNative(r, g, b, outH, (float*)poutS, (float*)poutV);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float outH, ref float outS, ref float outV)
		{
			fixed (float* poutH = &outH)
			{
				fixed (float* poutS = &outS)
				{
					fixed (float* poutV = &outV)
					{
						ColorConvertRGBtoHSVNative(r, g, b, (float*)poutH, (float*)poutS, (float*)poutV);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorConvertHSVtoRGBNative(float h, float s, float v, float* outR, float* outG, float* outB)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float*, float*, float*, void>)funcTable[369])(h, s, v, outR, outG, outB);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, nint, nint, nint, void>)funcTable[369])(h, s, v, (nint)outR, (nint)outG, (nint)outB);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, float* outG, float* outB)
		{
			ColorConvertHSVtoRGBNative(h, s, v, outR, outG, outB);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, float* outG, float* outB)
		{
			fixed (float* poutR = &outR)
			{
				ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, outG, outB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, ref float outG, float* outB)
		{
			fixed (float* poutG = &outG)
			{
				ColorConvertHSVtoRGBNative(h, s, v, outR, (float*)poutG, outB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, ref float outG, float* outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, (float*)poutG, outB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, float* outG, ref float outB)
		{
			fixed (float* poutB = &outB)
			{
				ColorConvertHSVtoRGBNative(h, s, v, outR, outG, (float*)poutB);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, float* outG, ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutB = &outB)
				{
					ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, outG, (float*)poutB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertHSVtoRGB(float h, float s, float v, float* outR, ref float outG, ref float outB)
		{
			fixed (float* poutG = &outG)
			{
				fixed (float* poutB = &outB)
				{
					ColorConvertHSVtoRGBNative(h, s, v, outR, (float*)poutG, (float*)poutB);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float outR, ref float outG, ref float outB)
		{
			fixed (float* poutR = &outR)
			{
				fixed (float* poutG = &outG)
				{
					fixed (float* poutB = &outB)
					{
						ColorConvertHSVtoRGBNative(h, s, v, (float*)poutR, (float*)poutG, (float*)poutB);
					}
				}
			}
		}

		/// <summary>
		/// is key being held.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsKeyDownNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)funcTable[370])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)funcTable[370])(key);
			#endif
		}

		/// <summary>
		/// is key being held.<br/>
		/// </summary>
		public static bool IsKeyDown(ImGuiKey key)
		{
			byte ret = IsKeyDownNative(key);
			return ret != 0;
		}

		/// <summary>
		/// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay  KeyRepeatRate<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsKeyPressedNative(ImGuiKey key, byte repeat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte, byte>)funcTable[371])(key, repeat);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte, byte>)funcTable[371])(key, repeat);
			#endif
		}

		/// <summary>
		/// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay  KeyRepeatRate<br/>
		/// </summary>
		public static bool IsKeyPressed(ImGuiKey key, bool repeat)
		{
			byte ret = IsKeyPressedNative(key, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay  KeyRepeatRate<br/>
		/// </summary>
		public static bool IsKeyPressed(ImGuiKey key)
		{
			byte ret = IsKeyPressedNative(key, (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// was key released (went from Down to !Down)?<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsKeyReleasedNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)funcTable[372])(key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiKey, byte>)funcTable[372])(key);
			#endif
		}

		/// <summary>
		/// was key released (went from Down to !Down)?<br/>
		/// </summary>
		public static bool IsKeyReleased(ImGuiKey key)
		{
			byte ret = IsKeyReleasedNative(key);
			return ret != 0;
		}

		/// <summary>
		/// was key chord (mods + key) pressed, e.g. you can pass 'ImGuiMod_Ctrl | ImGuiKey_S' as a key-chord. This doesn't do any routing or focus check, please consider using Shortcut() function instead.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsKeyChordPressedNative(int keyChord)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte>)funcTable[373])(keyChord);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, byte>)funcTable[373])(keyChord);
			#endif
		}

		/// <summary>
		/// was key chord (mods + key) pressed, e.g. you can pass 'ImGuiMod_Ctrl | ImGuiKey_S' as a key-chord. This doesn't do any routing or focus check, please consider using Shortcut() function instead.<br/>
		/// </summary>
		public static bool IsKeyChordPressed(int keyChord)
		{
			byte ret = IsKeyChordPressedNative(keyChord);
			return ret != 0;
		}

		/// <summary>
		/// uses provided repeat ratedelay. return a count, most often 0 or 1 but might be &gt;1 if RepeatRate is small enough that DeltaTime &gt; RepeatRate<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetKeyPressedAmountNative(ImGuiKey key, float repeatDelay, float rate)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, float, float, int>)funcTable[374])(key, repeatDelay, rate);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImGuiKey, float, float, int>)funcTable[374])(key, repeatDelay, rate);
			#endif
		}

		/// <summary>
		/// uses provided repeat ratedelay. return a count, most often 0 or 1 but might be &gt;1 if RepeatRate is small enough that DeltaTime &gt; RepeatRate<br/>
		/// </summary>
		public static int GetKeyPressedAmount(ImGuiKey key, float repeatDelay, float rate)
		{
			int ret = GetKeyPressedAmountNative(key, repeatDelay, rate);
			return ret;
		}

		/// <summary>
		/// [DEBUG] returns English name of the key. Those names are provided for debugging purpose and are not meant to be saved persistently nor compared.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetKeyNameNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiKey, byte*>)funcTable[375])(key);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<ImGuiKey, nint>)funcTable[375])(key);
			#endif
		}

		/// <summary>
		/// [DEBUG] returns English name of the key. Those names are provided for debugging purpose and are not meant to be saved persistently nor compared.<br/>
		/// </summary>
		public static byte* GetKeyName(ImGuiKey key)
		{
			byte* ret = GetKeyNameNative(key);
			return ret;
		}

		/// <summary>
		/// [DEBUG] returns English name of the key. Those names are provided for debugging purpose and are not meant to be saved persistently nor compared.<br/>
		/// </summary>
		public static string GetKeyNameS(ImGuiKey key)
		{
			string ret = Utils.DecodeStringUTF8(GetKeyNameNative(key));
			return ret;
		}

		/// <summary>
		/// Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard"; after the next NewFrame() call.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextFrameWantCaptureKeyboardNative(byte wantCaptureKeyboard)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[376])(wantCaptureKeyboard);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[376])(wantCaptureKeyboard);
			#endif
		}

		/// <summary>
		/// Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard"; after the next NewFrame() call.<br/>
		/// </summary>
		public static void SetNextFrameWantCaptureKeyboard(bool wantCaptureKeyboard)
		{
			SetNextFrameWantCaptureKeyboardNative(wantCaptureKeyboard ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShortcutNative(int keyChord, ImGuiInputFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, byte>)funcTable[377])(keyChord, flags);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, byte>)funcTable[377])(keyChord, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Shortcut(int keyChord, ImGuiInputFlags flags)
		{
			byte ret = ShortcutNative(keyChord, flags);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool Shortcut(int keyChord)
		{
			byte ret = ShortcutNative(keyChord, (ImGuiInputFlags)(0));
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextItemShortcutNative(int keyChord, ImGuiInputFlags flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, void>)funcTable[378])(keyChord, flags);
			#else
			((delegate* unmanaged[Cdecl]<int, ImGuiInputFlags, void>)funcTable[378])(keyChord, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextItemShortcut(int keyChord, ImGuiInputFlags flags)
		{
			SetNextItemShortcutNative(keyChord, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetNextItemShortcut(int keyChord)
		{
			SetNextItemShortcutNative(keyChord, (ImGuiInputFlags)(0));
		}

		/// <summary>
		/// Set key owner to last item ID if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive())  SetKeyOwner(key, GetItemID());'.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetItemKeyOwnerNative(ImGuiKey key)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiKey, void>)funcTable[379])(key);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiKey, void>)funcTable[379])(key);
			#endif
		}

		/// <summary>
		/// Set key owner to last item ID if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive())  SetKeyOwner(key, GetItemID());'.<br/>
		/// </summary>
		public static void SetItemKeyOwner(ImGuiKey key)
		{
			SetItemKeyOwnerNative(key);
		}

		/// <summary>
		/// is mouse button held?<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseDownNative(ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)funcTable[380])(button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)funcTable[380])(button);
			#endif
		}

		/// <summary>
		/// is mouse button held?<br/>
		/// </summary>
		public static bool IsMouseDown(ImGuiMouseButton button)
		{
			byte ret = IsMouseDownNative(button);
			return ret != 0;
		}

		/// <summary>
		/// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseClickedNative(ImGuiMouseButton button, byte repeat)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte, byte>)funcTable[381])(button, repeat);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte, byte>)funcTable[381])(button, repeat);
			#endif
		}

		/// <summary>
		/// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.<br/>
		/// </summary>
		public static bool IsMouseClicked(ImGuiMouseButton button, bool repeat)
		{
			byte ret = IsMouseClickedNative(button, repeat ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.<br/>
		/// </summary>
		public static bool IsMouseClicked(ImGuiMouseButton button)
		{
			byte ret = IsMouseClickedNative(button, (byte)(0));
			return ret != 0;
		}

		/// <summary>
		/// did mouse button released? (went from Down to !Down)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseReleasedNative(ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)funcTable[382])(button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)funcTable[382])(button);
			#endif
		}

		/// <summary>
		/// did mouse button released? (went from Down to !Down)<br/>
		/// </summary>
		public static bool IsMouseReleased(ImGuiMouseButton button)
		{
			byte ret = IsMouseReleasedNative(button);
			return ret != 0;
		}

		/// <summary>
		/// did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseDoubleClickedNative(ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)funcTable[383])(button);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, byte>)funcTable[383])(button);
			#endif
		}

		/// <summary>
		/// did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)<br/>
		/// </summary>
		public static bool IsMouseDoubleClicked(ImGuiMouseButton button)
		{
			byte ret = IsMouseDoubleClickedNative(button);
			return ret != 0;
		}

		/// <summary>
		/// delayed mouse release (use very sparingly!). Generally used with 'delay &gt;= io.MouseDoubleClickTime' + combined with a 'io.MouseClickedLastCount==1' test. This is a very rarely used UI idiom, but some apps use this: e.g. MS Explorer single click on an icon to rename.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseReleasedWithDelayNative(ImGuiMouseButton button, float delay)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, float, byte>)funcTable[384])(button, delay);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, float, byte>)funcTable[384])(button, delay);
			#endif
		}

		/// <summary>
		/// delayed mouse release (use very sparingly!). Generally used with 'delay &gt;= io.MouseDoubleClickTime' + combined with a 'io.MouseClickedLastCount==1' test. This is a very rarely used UI idiom, but some apps use this: e.g. MS Explorer single click on an icon to rename.<br/>
		/// </summary>
		public static bool IsMouseReleasedWithDelay(ImGuiMouseButton button, float delay)
		{
			byte ret = IsMouseReleasedWithDelayNative(button, delay);
			return ret != 0;
		}

		/// <summary>
		/// return the number of successive mouse-clicks at the time where a click happen (otherwise 0).<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetMouseClickedCountNative(ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, int>)funcTable[385])(button);
			#else
			return (int)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, int>)funcTable[385])(button);
			#endif
		}

		/// <summary>
		/// return the number of successive mouse-clicks at the time where a click happen (otherwise 0).<br/>
		/// </summary>
		public static int GetMouseClickedCount(ImGuiMouseButton button)
		{
			int ret = GetMouseClickedCountNative(button);
			return ret;
		}

		/// <summary>
		/// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focuswindow orderingpopup-block.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseHoveringRectNative(Vector2 rMin, Vector2 rMax, byte clip)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte, byte>)funcTable[386])(rMin, rMax, clip);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, Vector2, byte, byte>)funcTable[386])(rMin, rMax, clip);
			#endif
		}

		/// <summary>
		/// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focuswindow orderingpopup-block.<br/>
		/// </summary>
		public static bool IsMouseHoveringRect(Vector2 rMin, Vector2 rMax, bool clip)
		{
			byte ret = IsMouseHoveringRectNative(rMin, rMax, clip ? (byte)1 : (byte)0);
			return ret != 0;
		}

		/// <summary>
		/// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focuswindow orderingpopup-block.<br/>
		/// </summary>
		public static bool IsMouseHoveringRect(Vector2 rMin, Vector2 rMax)
		{
			byte ret = IsMouseHoveringRectNative(rMin, rMax, (byte)(1));
			return ret != 0;
		}

		/// <summary>
		/// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMousePosValidNative(Vector2* mousePos)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*, byte>)funcTable[387])(mousePos);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)funcTable[387])((nint)mousePos);
			#endif
		}

		/// <summary>
		/// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available<br/>
		/// </summary>
		public static bool IsMousePosValid(Vector2* mousePos)
		{
			byte ret = IsMousePosValidNative(mousePos);
			return ret != 0;
		}

		/// <summary>
		/// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available<br/>
		/// </summary>
		public static bool IsMousePosValid()
		{
			byte ret = IsMousePosValidNative((Vector2*)(default));
			return ret != 0;
		}

		/// <summary>
		/// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available<br/>
		/// </summary>
		public static bool IsMousePosValid(ref Vector2 mousePos)
		{
			fixed (Vector2* pmousePos = &mousePos)
			{
				byte ret = IsMousePosValidNative((Vector2*)pmousePos);
				return ret != 0;
			}
		}

		/// <summary>
		/// [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsAnyMouseDownNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte>)funcTable[388])();
			#else
			return (byte)((delegate* unmanaged[Cdecl]<byte>)funcTable[388])();
			#endif
		}

		/// <summary>
		/// [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.<br/>
		/// </summary>
		public static bool IsAnyMouseDown()
		{
			byte ret = IsAnyMouseDownNative();
			return ret != 0;
		}

		/// <summary>
		/// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMousePosNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[389])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[389])((nint)pOut);
			#endif
		}

		/// <summary>
		/// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls<br/>
		/// </summary>
		public static Vector2 GetMousePos()
		{
			Vector2 ret;
			GetMousePosNative(&ret);
			return ret;
		}

		/// <summary>
		/// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls<br/>
		/// </summary>
		public static void GetMousePos(Vector2* pOut)
		{
			GetMousePosNative(pOut);
		}

		/// <summary>
		/// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls<br/>
		/// </summary>
		public static void GetMousePos(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMousePosNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMousePosOnOpeningCurrentPopupNative(Vector2* pOut)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, void>)funcTable[390])(pOut);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[390])((nint)pOut);
			#endif
		}

		/// <summary>
		/// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)<br/>
		/// </summary>
		public static Vector2 GetMousePosOnOpeningCurrentPopup()
		{
			Vector2 ret;
			GetMousePosOnOpeningCurrentPopupNative(&ret);
			return ret;
		}

		/// <summary>
		/// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)<br/>
		/// </summary>
		public static void GetMousePosOnOpeningCurrentPopup(Vector2* pOut)
		{
			GetMousePosOnOpeningCurrentPopupNative(pOut);
		}

		/// <summary>
		/// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)<br/>
		/// </summary>
		public static void GetMousePosOnOpeningCurrentPopup(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMousePosOnOpeningCurrentPopupNative((Vector2*)ppOut);
			}
		}

		/// <summary>
		/// is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMouseDraggingNative(ImGuiMouseButton button, float lockThreshold)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseButton, float, byte>)funcTable[391])(button, lockThreshold);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImGuiMouseButton, float, byte>)funcTable[391])(button, lockThreshold);
			#endif
		}

		/// <summary>
		/// is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static bool IsMouseDragging(ImGuiMouseButton button, float lockThreshold)
		{
			byte ret = IsMouseDraggingNative(button, lockThreshold);
			return ret != 0;
		}

		/// <summary>
		/// is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static bool IsMouseDragging(ImGuiMouseButton button)
		{
			byte ret = IsMouseDraggingNative(button, (float)(-1.0f));
			return ret != 0;
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMouseDragDeltaNative(Vector2* pOut, ImGuiMouseButton button, float lockThreshold)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Vector2*, ImGuiMouseButton, float, void>)funcTable[392])(pOut, button, lockThreshold);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiMouseButton, float, void>)funcTable[392])((nint)pOut, button, lockThreshold);
			#endif
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static Vector2 GetMouseDragDelta()
		{
			Vector2 ret;
			GetMouseDragDeltaNative(&ret, (ImGuiMouseButton)(0), (float)(-1.0f));
			return ret;
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static Vector2 GetMouseDragDelta(ImGuiMouseButton button)
		{
			Vector2 ret;
			GetMouseDragDeltaNative(&ret, button, (float)(-1.0f));
			return ret;
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static void GetMouseDragDelta(Vector2* pOut)
		{
			GetMouseDragDeltaNative(pOut, (ImGuiMouseButton)(0), (float)(-1.0f));
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static Vector2 GetMouseDragDelta(float lockThreshold)
		{
			Vector2 ret;
			GetMouseDragDeltaNative(&ret, (ImGuiMouseButton)(0), lockThreshold);
			return ret;
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static Vector2 GetMouseDragDelta(ImGuiMouseButton button, float lockThreshold)
		{
			Vector2 ret;
			GetMouseDragDeltaNative(&ret, button, lockThreshold);
			return ret;
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static void GetMouseDragDelta(Vector2* pOut, ImGuiMouseButton button, float lockThreshold)
		{
			GetMouseDragDeltaNative(pOut, button, lockThreshold);
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static void GetMouseDragDelta(Vector2* pOut, ImGuiMouseButton button)
		{
			GetMouseDragDeltaNative(pOut, button, (float)(-1.0f));
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static void GetMouseDragDelta(Vector2* pOut, float lockThreshold)
		{
			GetMouseDragDeltaNative(pOut, (ImGuiMouseButton)(0), lockThreshold);
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static void GetMouseDragDelta(ref Vector2 pOut, ImGuiMouseButton button, float lockThreshold)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMouseDragDeltaNative((Vector2*)ppOut, button, lockThreshold);
			}
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static void GetMouseDragDelta(ref Vector2 pOut, ImGuiMouseButton button)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMouseDragDeltaNative((Vector2*)ppOut, button, (float)(-1.0f));
			}
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static void GetMouseDragDelta(ref Vector2 pOut)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMouseDragDeltaNative((Vector2*)ppOut, (ImGuiMouseButton)(0), (float)(-1.0f));
			}
		}

		/// <summary>
		/// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold &lt; 0.0f)<br/>
		/// </summary>
		public static void GetMouseDragDelta(ref Vector2 pOut, float lockThreshold)
		{
			fixed (Vector2* ppOut = &pOut)
			{
				GetMouseDragDeltaNative((Vector2*)ppOut, (ImGuiMouseButton)(0), lockThreshold);
			}
		}

		/// <summary>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetMouseDragDeltaNative(ImGuiMouseButton button)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMouseButton, void>)funcTable[393])(button);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiMouseButton, void>)funcTable[393])(button);
			#endif
		}

		/// <summary>
		/// </summary>
		public static void ResetMouseDragDelta(ImGuiMouseButton button)
		{
			ResetMouseDragDeltaNative(button);
		}

		/// <summary>
		/// </summary>
		public static void ResetMouseDragDelta()
		{
			ResetMouseDragDeltaNative((ImGuiMouseButton)(0));
		}

		/// <summary>
		/// get desired mouse cursor shape. Important: reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiMouseCursor GetMouseCursorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiMouseCursor>)funcTable[394])();
			#else
			return (ImGuiMouseCursor)((delegate* unmanaged[Cdecl]<ImGuiMouseCursor>)funcTable[394])();
			#endif
		}

		/// <summary>
		/// get desired mouse cursor shape. Important: reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you<br/>
		/// </summary>
		public static ImGuiMouseCursor GetMouseCursor()
		{
			ImGuiMouseCursor ret = GetMouseCursorNative();
			return ret;
		}

		/// <summary>
		/// set desired mouse cursor shape<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetMouseCursorNative(ImGuiMouseCursor cursorType)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiMouseCursor, void>)funcTable[395])(cursorType);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiMouseCursor, void>)funcTable[395])(cursorType);
			#endif
		}

		/// <summary>
		/// set desired mouse cursor shape<br/>
		/// </summary>
		public static void SetMouseCursor(ImGuiMouseCursor cursorType)
		{
			SetMouseCursorNative(cursorType);
		}

		/// <summary>
		/// Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instructs your app to ignore inputs). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse;" after the next NewFrame() call.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetNextFrameWantCaptureMouseNative(byte wantCaptureMouse)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[396])(wantCaptureMouse);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[396])(wantCaptureMouse);
			#endif
		}

		/// <summary>
		/// Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instructs your app to ignore inputs). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse;" after the next NewFrame() call.<br/>
		/// </summary>
		public static void SetNextFrameWantCaptureMouse(bool wantCaptureMouse)
		{
			SetNextFrameWantCaptureMouseNative(wantCaptureMouse ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetClipboardTextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[397])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[397])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* GetClipboardText()
		{
			byte* ret = GetClipboardTextNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string GetClipboardTextS()
		{
			string ret = Utils.DecodeStringUTF8(GetClipboardTextNative());
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetClipboardTextNative(byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[398])(text);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[398])((nint)text);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetClipboardText(byte* text)
		{
			SetClipboardTextNative(text);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetClipboardText(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				SetClipboardTextNative((byte*)ptext);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetClipboardText(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				SetClipboardTextNative((byte*)ptext);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetClipboardText(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetClipboardTextNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadIniSettingsFromDiskNative(byte* iniFilename)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[399])(iniFilename);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[399])((nint)iniFilename);
			#endif
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).<br/>
		/// </summary>
		public static void LoadIniSettingsFromDisk(byte* iniFilename)
		{
			LoadIniSettingsFromDiskNative(iniFilename);
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).<br/>
		/// </summary>
		public static void LoadIniSettingsFromDisk(ref byte iniFilename)
		{
			fixed (byte* piniFilename = &iniFilename)
			{
				LoadIniSettingsFromDiskNative((byte*)piniFilename);
			}
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).<br/>
		/// </summary>
		public static void LoadIniSettingsFromDisk(ReadOnlySpan<byte> iniFilename)
		{
			fixed (byte* piniFilename = iniFilename)
			{
				LoadIniSettingsFromDiskNative((byte*)piniFilename);
			}
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).<br/>
		/// </summary>
		public static void LoadIniSettingsFromDisk(string iniFilename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniFilename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniFilename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniFilename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LoadIniSettingsFromDiskNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadIniSettingsFromMemoryNative(byte* iniData, nuint iniSize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, nuint, void>)funcTable[400])(iniData, iniSize);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, void>)funcTable[400])((nint)iniData, iniSize);
			#endif
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.<br/>
		/// </summary>
		public static void LoadIniSettingsFromMemory(byte* iniData, nuint iniSize)
		{
			LoadIniSettingsFromMemoryNative(iniData, iniSize);
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.<br/>
		/// </summary>
		public static void LoadIniSettingsFromMemory(byte* iniData)
		{
			LoadIniSettingsFromMemoryNative(iniData, (nuint)(0));
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.<br/>
		/// </summary>
		public static void LoadIniSettingsFromMemory(ref byte iniData, nuint iniSize)
		{
			fixed (byte* piniData = &iniData)
			{
				LoadIniSettingsFromMemoryNative((byte*)piniData, iniSize);
			}
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.<br/>
		/// </summary>
		public static void LoadIniSettingsFromMemory(ref byte iniData)
		{
			fixed (byte* piniData = &iniData)
			{
				LoadIniSettingsFromMemoryNative((byte*)piniData, (nuint)(0));
			}
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.<br/>
		/// </summary>
		public static void LoadIniSettingsFromMemory(ReadOnlySpan<byte> iniData, nuint iniSize)
		{
			fixed (byte* piniData = iniData)
			{
				LoadIniSettingsFromMemoryNative((byte*)piniData, iniSize);
			}
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.<br/>
		/// </summary>
		public static void LoadIniSettingsFromMemory(ReadOnlySpan<byte> iniData)
		{
			fixed (byte* piniData = iniData)
			{
				LoadIniSettingsFromMemoryNative((byte*)piniData, (nuint)(0));
			}
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.<br/>
		/// </summary>
		public static void LoadIniSettingsFromMemory(string iniData, nuint iniSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniData != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniData);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniData, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LoadIniSettingsFromMemoryNative(pStr0, iniSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.<br/>
		/// </summary>
		public static void LoadIniSettingsFromMemory(string iniData)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniData != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniData);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniData, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LoadIniSettingsFromMemoryNative(pStr0, (nuint)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SaveIniSettingsToDiskNative(byte* iniFilename)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[401])(iniFilename);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[401])((nint)iniFilename);
			#endif
		}

		/// <summary>
		/// this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).<br/>
		/// </summary>
		public static void SaveIniSettingsToDisk(byte* iniFilename)
		{
			SaveIniSettingsToDiskNative(iniFilename);
		}

		/// <summary>
		/// this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).<br/>
		/// </summary>
		public static void SaveIniSettingsToDisk(ref byte iniFilename)
		{
			fixed (byte* piniFilename = &iniFilename)
			{
				SaveIniSettingsToDiskNative((byte*)piniFilename);
			}
		}

		/// <summary>
		/// this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).<br/>
		/// </summary>
		public static void SaveIniSettingsToDisk(ReadOnlySpan<byte> iniFilename)
		{
			fixed (byte* piniFilename = iniFilename)
			{
				SaveIniSettingsToDiskNative((byte*)piniFilename);
			}
		}

		/// <summary>
		/// this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).<br/>
		/// </summary>
		public static void SaveIniSettingsToDisk(string iniFilename)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (iniFilename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(iniFilename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(iniFilename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SaveIniSettingsToDiskNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* SaveIniSettingsToMemoryNative(nuint* outIniSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint*, byte*>)funcTable[402])(outIniSize);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[402])((nint)outIniSize);
			#endif
		}

		/// <summary>
		/// return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.<br/>
		/// </summary>
		public static byte* SaveIniSettingsToMemory(nuint* outIniSize)
		{
			byte* ret = SaveIniSettingsToMemoryNative(outIniSize);
			return ret;
		}

		/// <summary>
		/// return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.<br/>
		/// </summary>
		public static byte* SaveIniSettingsToMemory()
		{
			byte* ret = SaveIniSettingsToMemoryNative((nuint*)(default));
			return ret;
		}

		/// <summary>
		/// return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.<br/>
		/// </summary>
		public static string SaveIniSettingsToMemoryS()
		{
			string ret = Utils.DecodeStringUTF8(SaveIniSettingsToMemoryNative((nuint*)(default)));
			return ret;
		}

		/// <summary>
		/// return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.<br/>
		/// </summary>
		public static string SaveIniSettingsToMemoryS(nuint* outIniSize)
		{
			string ret = Utils.DecodeStringUTF8(SaveIniSettingsToMemoryNative(outIniSize));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugTextEncodingNative(byte* text)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[403])(text);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[403])((nint)text);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugTextEncoding(byte* text)
		{
			DebugTextEncodingNative(text);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugTextEncoding(ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				DebugTextEncodingNative((byte*)ptext);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugTextEncoding(ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				DebugTextEncodingNative((byte*)ptext);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugTextEncoding(string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugTextEncodingNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugFlashStyleColorNative(ImGuiCol idx)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiCol, void>)funcTable[404])(idx);
			#else
			((delegate* unmanaged[Cdecl]<ImGuiCol, void>)funcTable[404])(idx);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugFlashStyleColor(ImGuiCol idx)
		{
			DebugFlashStyleColorNative(idx);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugStartItemPickerNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[405])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[405])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugStartItemPicker()
		{
			DebugStartItemPickerNative();
		}

		/// <summary>
		/// This is called by IMGUI_CHECKVERSION() macro.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DebugCheckVersionAndDataLayoutNative(byte* versionStr, nuint szIo, nuint szStyle, nuint szvec2, nuint szvec4, nuint szDrawvert, nuint szDrawidx)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, nuint, nuint, nuint, nuint, nuint, nuint, byte>)funcTable[406])(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, nuint, nuint, nuint, nuint, nuint, nuint, byte>)funcTable[406])((nint)versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			#endif
		}

		/// <summary>
		/// This is called by IMGUI_CHECKVERSION() macro.<br/>
		/// </summary>
		public static bool DebugCheckVersionAndDataLayout(byte* versionStr, nuint szIo, nuint szStyle, nuint szvec2, nuint szvec4, nuint szDrawvert, nuint szDrawidx)
		{
			byte ret = DebugCheckVersionAndDataLayoutNative(versionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			return ret != 0;
		}

		/// <summary>
		/// This is called by IMGUI_CHECKVERSION() macro.<br/>
		/// </summary>
		public static bool DebugCheckVersionAndDataLayout(ref byte versionStr, nuint szIo, nuint szStyle, nuint szvec2, nuint szvec4, nuint szDrawvert, nuint szDrawidx)
		{
			fixed (byte* pversionStr = &versionStr)
			{
				byte ret = DebugCheckVersionAndDataLayoutNative((byte*)pversionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
				return ret != 0;
			}
		}

		/// <summary>
		/// This is called by IMGUI_CHECKVERSION() macro.<br/>
		/// </summary>
		public static bool DebugCheckVersionAndDataLayout(ReadOnlySpan<byte> versionStr, nuint szIo, nuint szStyle, nuint szvec2, nuint szvec4, nuint szDrawvert, nuint szDrawidx)
		{
			fixed (byte* pversionStr = versionStr)
			{
				byte ret = DebugCheckVersionAndDataLayoutNative((byte*)pversionStr, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
				return ret != 0;
			}
		}

		/// <summary>
		/// This is called by IMGUI_CHECKVERSION() macro.<br/>
		/// </summary>
		public static bool DebugCheckVersionAndDataLayout(string versionStr, nuint szIo, nuint szStyle, nuint szvec2, nuint szvec4, nuint szDrawvert, nuint szDrawidx)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (versionStr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(versionStr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(versionStr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = DebugCheckVersionAndDataLayoutNative(pStr0, szIo, szStyle, szvec2, szvec4, szDrawvert, szDrawidx);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		/// <summary>
		/// Call via IMGUI_DEBUG_LOG() for maximum stripping in caller code!<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugLogNative(byte* fmt)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[407])(fmt);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[407])((nint)fmt);
			#endif
		}

		/// <summary>
		/// Call via IMGUI_DEBUG_LOG() for maximum stripping in caller code!<br/>
		/// </summary>
		public static void DebugLog(byte* fmt)
		{
			DebugLogNative(fmt);
		}

		/// <summary>
		/// Call via IMGUI_DEBUG_LOG() for maximum stripping in caller code!<br/>
		/// </summary>
		public static void DebugLog(ref byte fmt)
		{
			fixed (byte* pfmt = &fmt)
			{
				DebugLogNative((byte*)pfmt);
			}
		}

		/// <summary>
		/// Call via IMGUI_DEBUG_LOG() for maximum stripping in caller code!<br/>
		/// </summary>
		public static void DebugLog(ReadOnlySpan<byte> fmt)
		{
			fixed (byte* pfmt = fmt)
			{
				DebugLogNative((byte*)pfmt);
			}
		}

		/// <summary>
		/// Call via IMGUI_DEBUG_LOG() for maximum stripping in caller code!<br/>
		/// </summary>
		public static void DebugLog(string fmt)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugLogNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugLogVNative(byte* fmt, nuint args)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, nuint, void>)funcTable[408])(fmt, args);
			#else
			((delegate* unmanaged[Cdecl]<nint, nuint, void>)funcTable[408])((nint)fmt, args);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugLogV(byte* fmt, nuint args)
		{
			DebugLogVNative(fmt, args);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugLogV(ref byte fmt, nuint args)
		{
			fixed (byte* pfmt = &fmt)
			{
				DebugLogVNative((byte*)pfmt, args);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugLogV(ReadOnlySpan<byte> fmt, nuint args)
		{
			fixed (byte* pfmt = fmt)
			{
				DebugLogVNative((byte*)pfmt, args);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DebugLogV(string fmt, nuint args)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmt != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmt);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmt, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugLogVNative(pStr0, args);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAllocatorFunctionsNative(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc, void* userData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<nuint, void*, void*>, delegate*<void*, void*, void>, void*, void>)funcTable[409])((delegate*<nuint, void*, void*>)Utils.GetFunctionPointerForDelegate(allocFunc), (delegate*<void*, void*, void>)Utils.GetFunctionPointerForDelegate(freeFunc), userData);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[409])((nint)Utils.GetFunctionPointerForDelegate(allocFunc), (nint)Utils.GetFunctionPointerForDelegate(freeFunc), (nint)userData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAllocatorFunctions(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc, void* userData)
		{
			SetAllocatorFunctionsNative(allocFunc, freeFunc, userData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void SetAllocatorFunctions(ImGuiMemAllocFunc allocFunc, ImGuiMemFreeFunc freeFunc)
		{
			SetAllocatorFunctionsNative(allocFunc, freeFunc, (void*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetAllocatorFunctionsNative(delegate*<nuint, void*, void*>* pAllocFunc, delegate*<void*, void*, void>* pFreeFunc, void** pUserData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<nuint, void*, void*>*, delegate*<void*, void*, void>*, void**, void>)funcTable[410])(pAllocFunc, pFreeFunc, pUserData);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[410])((nint)pAllocFunc, (nint)pFreeFunc, (nint)pUserData);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void GetAllocatorFunctions(delegate*<nuint, void*, void*>* pAllocFunc, delegate*<void*, void*, void>* pFreeFunc, void** pUserData)
		{
			GetAllocatorFunctionsNative(pAllocFunc, pFreeFunc, pUserData);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MemAllocNative(nuint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<nuint, void*>)funcTable[411])(size);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nuint, nint>)funcTable[411])(size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* MemAlloc(nuint size)
		{
			void* ret = MemAllocNative(size);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemFreeNative(void* ptr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void>)funcTable[412])(ptr);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[412])((nint)ptr);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void MemFree(void* ptr)
		{
			MemFreeNative(ptr);
		}

		/// <summary>
		/// call in main loop. will call CreateWindowResizeWindowetc. platform functions for each secondary viewport, and DestroyWindow for each inactive viewport.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UpdatePlatformWindowsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[413])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[413])();
			#endif
		}

		/// <summary>
		/// call in main loop. will call CreateWindowResizeWindowetc. platform functions for each secondary viewport, and DestroyWindow for each inactive viewport.<br/>
		/// </summary>
		public static void UpdatePlatformWindows()
		{
			UpdatePlatformWindowsNative();
		}

		/// <summary>
		/// call in main loop. will call RenderWindowSwapBuffers platform functions for each secondary viewport which doesn't have the ImGuiViewportFlags_Minimized flag set. May be reimplemented by user for custom rendering needs.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderPlatformWindowsDefaultNative(void* platformRenderArg, void* rendererRenderArg)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void*, void>)funcTable[414])(platformRenderArg, rendererRenderArg);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[414])((nint)platformRenderArg, (nint)rendererRenderArg);
			#endif
		}

		/// <summary>
		/// call in main loop. will call RenderWindowSwapBuffers platform functions for each secondary viewport which doesn't have the ImGuiViewportFlags_Minimized flag set. May be reimplemented by user for custom rendering needs.<br/>
		/// </summary>
		public static void RenderPlatformWindowsDefault(void* platformRenderArg, void* rendererRenderArg)
		{
			RenderPlatformWindowsDefaultNative(platformRenderArg, rendererRenderArg);
		}

		/// <summary>
		/// call in main loop. will call RenderWindowSwapBuffers platform functions for each secondary viewport which doesn't have the ImGuiViewportFlags_Minimized flag set. May be reimplemented by user for custom rendering needs.<br/>
		/// </summary>
		public static void RenderPlatformWindowsDefault(void* platformRenderArg)
		{
			RenderPlatformWindowsDefaultNative(platformRenderArg, (void*)(default));
		}

		/// <summary>
		/// call in main loop. will call RenderWindowSwapBuffers platform functions for each secondary viewport which doesn't have the ImGuiViewportFlags_Minimized flag set. May be reimplemented by user for custom rendering needs.<br/>
		/// </summary>
		public static void RenderPlatformWindowsDefault()
		{
			RenderPlatformWindowsDefaultNative((void*)(default), (void*)(default));
		}

		/// <summary>
		/// call DestroyWindow platform functions for all viewports. call from backend Shutdown() if you need to close platform windows before imgui shutdown. otherwise will be called by DestroyContext().<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyPlatformWindowsNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[415])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[415])();
			#endif
		}

		/// <summary>
		/// call DestroyWindow platform functions for all viewports. call from backend Shutdown() if you need to close platform windows before imgui shutdown. otherwise will be called by DestroyContext().<br/>
		/// </summary>
		public static void DestroyPlatformWindows()
		{
			DestroyPlatformWindowsNative();
		}

		/// <summary>
		/// this is a helper for backends.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiViewport* FindViewportByIDNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ImGuiViewport*>)funcTable[416])(id);
			#else
			return (ImGuiViewport*)((delegate* unmanaged[Cdecl]<uint, nint>)funcTable[416])(id);
			#endif
		}

		/// <summary>
		/// this is a helper for backends.<br/>
		/// </summary>
		public static ImGuiViewportPtr FindViewportByID(uint id)
		{
			ImGuiViewportPtr ret = FindViewportByIDNative(id);
			return ret;
		}

		/// <summary>
		/// this is a helper for backends. the type platform_handle is decided by the backend (e.g. HWND, MyWindow*, GLFWwindow* etc.)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiViewport* FindViewportByPlatformHandleNative(void* platformHandle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, ImGuiViewport*>)funcTable[417])(platformHandle);
			#else
			return (ImGuiViewport*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[417])((nint)platformHandle);
			#endif
		}

		/// <summary>
		/// this is a helper for backends. the type platform_handle is decided by the backend (e.g. HWND, MyWindow*, GLFWwindow* etc.)<br/>
		/// </summary>
		public static ImGuiViewportPtr FindViewportByPlatformHandle(void* platformHandle)
		{
			ImGuiViewportPtr ret = FindViewportByPlatformHandleNative(platformHandle);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableSortSpecs* ImGuiTableSortSpecsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableSortSpecs*>)funcTable[418])();
			#else
			return (ImGuiTableSortSpecs*)((delegate* unmanaged[Cdecl]<nint>)funcTable[418])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableSortSpecsPtr ImGuiTableSortSpecs()
		{
			ImGuiTableSortSpecsPtr ret = ImGuiTableSortSpecsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTableSortSpecs* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTableSortSpecs*, void>)funcTable[419])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[419])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTableSortSpecsPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTableSortSpecs self)
		{
			fixed (ImGuiTableSortSpecs* pself = &self)
			{
				DestroyNative((ImGuiTableSortSpecs*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiTableColumnSortSpecs* ImGuiTableColumnSortSpecsNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiTableColumnSortSpecs*>)funcTable[420])();
			#else
			return (ImGuiTableColumnSortSpecs*)((delegate* unmanaged[Cdecl]<nint>)funcTable[420])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiTableColumnSortSpecsPtr ImGuiTableColumnSortSpecs()
		{
			ImGuiTableColumnSortSpecsPtr ret = ImGuiTableColumnSortSpecsNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiTableColumnSortSpecs* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiTableColumnSortSpecs*, void>)funcTable[421])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[421])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiTableColumnSortSpecsPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiTableColumnSortSpecs self)
		{
			fixed (ImGuiTableColumnSortSpecs* pself = &self)
			{
				DestroyNative((ImGuiTableColumnSortSpecs*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiStyle* ImGuiStyleNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiStyle*>)funcTable[422])();
			#else
			return (ImGuiStyle*)((delegate* unmanaged[Cdecl]<nint>)funcTable[422])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiStylePtr ImGuiStyle()
		{
			ImGuiStylePtr ret = ImGuiStyleNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiStyle* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, void>)funcTable[423])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[423])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiStylePtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiStyle self)
		{
			fixed (ImGuiStyle* pself = &self)
			{
				DestroyNative((ImGuiStyle*)pself);
			}
		}

		/// <summary>
		/// Scale all spacingpaddingthickness values. Do not scale fonts.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScaleAllSizesNative(ImGuiStyle* self, float scaleFactor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiStyle*, float, void>)funcTable[424])(self, scaleFactor);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, void>)funcTable[424])((nint)self, scaleFactor);
			#endif
		}

		/// <summary>
		/// Scale all spacingpaddingthickness values. Do not scale fonts.<br/>
		/// </summary>
		public static void ScaleAllSizes(ImGuiStylePtr self, float scaleFactor)
		{
			ScaleAllSizesNative(self, scaleFactor);
		}

		/// <summary>
		/// Scale all spacingpaddingthickness values. Do not scale fonts.<br/>
		/// </summary>
		public static void ScaleAllSizes(ref ImGuiStyle self, float scaleFactor)
		{
			fixed (ImGuiStyle* pself = &self)
			{
				ScaleAllSizesNative((ImGuiStyle*)pself, scaleFactor);
			}
		}

		/// <summary>
		/// Queue a new key downup event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddKeyEventNative(ImGuiIO* self, ImGuiKey key, byte down)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, ImGuiKey, byte, void>)funcTable[425])(self, key, down);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiKey, byte, void>)funcTable[425])((nint)self, key, down);
			#endif
		}

		/// <summary>
		/// Queue a new key downup event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)<br/>
		/// </summary>
		public static void AddKeyEvent(ImGuiIOPtr self, ImGuiKey key, bool down)
		{
			AddKeyEventNative(self, key, down ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Queue a new key downup event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)<br/>
		/// </summary>
		public static void AddKeyEvent(ref ImGuiIO self, ImGuiKey key, bool down)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddKeyEventNative((ImGuiIO*)pself, key, down ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Queue a new key downup event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddKeyAnalogEventNative(ImGuiIO* self, ImGuiKey key, byte down, float v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, ImGuiKey, byte, float, void>)funcTable[426])(self, key, down, v);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiKey, byte, float, void>)funcTable[426])((nint)self, key, down, v);
			#endif
		}

		/// <summary>
		/// Queue a new key downup event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.<br/>
		/// </summary>
		public static void AddKeyAnalogEvent(ImGuiIOPtr self, ImGuiKey key, bool down, float v)
		{
			AddKeyAnalogEventNative(self, key, down ? (byte)1 : (byte)0, v);
		}

		/// <summary>
		/// Queue a new key downup event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.<br/>
		/// </summary>
		public static void AddKeyAnalogEvent(ref ImGuiIO self, ImGuiKey key, bool down, float v)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddKeyAnalogEventNative((ImGuiIO*)pself, key, down ? (byte)1 : (byte)0, v);
			}
		}

		/// <summary>
		/// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddMousePosEventNative(ImGuiIO* self, float x, float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, float, float, void>)funcTable[427])(self, x, y);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, float, void>)funcTable[427])((nint)self, x, y);
			#endif
		}

		/// <summary>
		/// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)<br/>
		/// </summary>
		public static void AddMousePosEvent(ImGuiIOPtr self, float x, float y)
		{
			AddMousePosEventNative(self, x, y);
		}

		/// <summary>
		/// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)<br/>
		/// </summary>
		public static void AddMousePosEvent(ref ImGuiIO self, float x, float y)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMousePosEventNative((ImGuiIO*)pself, x, y);
			}
		}

		/// <summary>
		/// Queue a mouse button change<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddMouseButtonEventNative(ImGuiIO* self, int button, byte down)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, int, byte, void>)funcTable[428])(self, button, down);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, byte, void>)funcTable[428])((nint)self, button, down);
			#endif
		}

		/// <summary>
		/// Queue a mouse button change<br/>
		/// </summary>
		public static void AddMouseButtonEvent(ImGuiIOPtr self, int button, bool down)
		{
			AddMouseButtonEventNative(self, button, down ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Queue a mouse button change<br/>
		/// </summary>
		public static void AddMouseButtonEvent(ref ImGuiIO self, int button, bool down)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseButtonEventNative((ImGuiIO*)pself, button, down ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Queue a mouse wheel update. wheel_y&lt;0: scroll down, wheel_y&gt;0: scroll up, wheel_x&lt;0: scroll right, wheel_x&gt;0: scroll left.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddMouseWheelEventNative(ImGuiIO* self, float wheelX, float wheelY)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, float, float, void>)funcTable[429])(self, wheelX, wheelY);
			#else
			((delegate* unmanaged[Cdecl]<nint, float, float, void>)funcTable[429])((nint)self, wheelX, wheelY);
			#endif
		}

		/// <summary>
		/// Queue a mouse wheel update. wheel_y&lt;0: scroll down, wheel_y&gt;0: scroll up, wheel_x&lt;0: scroll right, wheel_x&gt;0: scroll left.<br/>
		/// </summary>
		public static void AddMouseWheelEvent(ImGuiIOPtr self, float wheelX, float wheelY)
		{
			AddMouseWheelEventNative(self, wheelX, wheelY);
		}

		/// <summary>
		/// Queue a mouse wheel update. wheel_y&lt;0: scroll down, wheel_y&gt;0: scroll up, wheel_x&lt;0: scroll right, wheel_x&gt;0: scroll left.<br/>
		/// </summary>
		public static void AddMouseWheelEvent(ref ImGuiIO self, float wheelX, float wheelY)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseWheelEventNative((ImGuiIO*)pself, wheelX, wheelY);
			}
		}

		/// <summary>
		/// Queue a mouse source change (MouseTouchScreenPen)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddMouseSourceEventNative(ImGuiIO* self, ImGuiMouseSource source)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, ImGuiMouseSource, void>)funcTable[430])(self, source);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiMouseSource, void>)funcTable[430])((nint)self, source);
			#endif
		}

		/// <summary>
		/// Queue a mouse source change (MouseTouchScreenPen)<br/>
		/// </summary>
		public static void AddMouseSourceEvent(ImGuiIOPtr self, ImGuiMouseSource source)
		{
			AddMouseSourceEventNative(self, source);
		}

		/// <summary>
		/// Queue a mouse source change (MouseTouchScreenPen)<br/>
		/// </summary>
		public static void AddMouseSourceEvent(ref ImGuiIO self, ImGuiMouseSource source)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseSourceEventNative((ImGuiIO*)pself, source);
			}
		}

		/// <summary>
		/// Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddMouseViewportEventNative(ImGuiIO* self, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, uint, void>)funcTable[431])(self, id);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)funcTable[431])((nint)self, id);
			#endif
		}

		/// <summary>
		/// Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).<br/>
		/// </summary>
		public static void AddMouseViewportEvent(ImGuiIOPtr self, uint id)
		{
			AddMouseViewportEventNative(self, id);
		}

		/// <summary>
		/// Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).<br/>
		/// </summary>
		public static void AddMouseViewportEvent(ref ImGuiIO self, uint id)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddMouseViewportEventNative((ImGuiIO*)pself, id);
			}
		}

		/// <summary>
		/// Queue a gainloss of focus for the application (generally based on OSplatform focus of your window)<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddFocusEventNative(ImGuiIO* self, byte focused)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, byte, void>)funcTable[432])(self, focused);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[432])((nint)self, focused);
			#endif
		}

		/// <summary>
		/// Queue a gainloss of focus for the application (generally based on OSplatform focus of your window)<br/>
		/// </summary>
		public static void AddFocusEvent(ImGuiIOPtr self, bool focused)
		{
			AddFocusEventNative(self, focused ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Queue a gainloss of focus for the application (generally based on OSplatform focus of your window)<br/>
		/// </summary>
		public static void AddFocusEvent(ref ImGuiIO self, bool focused)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddFocusEventNative((ImGuiIO*)pself, focused ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Queue a new character input<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddInputCharacterNative(ImGuiIO* self, uint c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, uint, void>)funcTable[433])(self, c);
			#else
			((delegate* unmanaged[Cdecl]<nint, uint, void>)funcTable[433])((nint)self, c);
			#endif
		}

		/// <summary>
		/// Queue a new character input<br/>
		/// </summary>
		public static void AddInputCharacter(ImGuiIOPtr self, uint c)
		{
			AddInputCharacterNative(self, c);
		}

		/// <summary>
		/// Queue a new character input<br/>
		/// </summary>
		public static void AddInputCharacter(ref ImGuiIO self, uint c)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddInputCharacterNative((ImGuiIO*)pself, c);
			}
		}

		/// <summary>
		/// Queue a new character input from a UTF-16 character, it can be a surrogate<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddInputCharacterUTF16Native(ImGuiIO* self, ushort c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, ushort, void>)funcTable[434])(self, c);
			#else
			((delegate* unmanaged[Cdecl]<nint, ushort, void>)funcTable[434])((nint)self, c);
			#endif
		}

		/// <summary>
		/// Queue a new character input from a UTF-16 character, it can be a surrogate<br/>
		/// </summary>
		public static void AddInputCharacterUTF16(ImGuiIOPtr self, ushort c)
		{
			AddInputCharacterUTF16Native(self, c);
		}

		/// <summary>
		/// Queue a new character input from a UTF-16 character, it can be a surrogate<br/>
		/// </summary>
		public static void AddInputCharacterUTF16(ref ImGuiIO self, ushort c)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddInputCharacterUTF16Native((ImGuiIO*)pself, c);
			}
		}

		/// <summary>
		/// Queue a new characters input from a UTF-8 string<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AddInputCharactersUTF8Native(ImGuiIO* self, byte* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, byte*, void>)funcTable[435])(self, str);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[435])((nint)self, (nint)str);
			#endif
		}

		/// <summary>
		/// Queue a new characters input from a UTF-8 string<br/>
		/// </summary>
		public static void AddInputCharactersUTF8(ImGuiIOPtr self, byte* str)
		{
			AddInputCharactersUTF8Native(self, str);
		}

		/// <summary>
		/// Queue a new characters input from a UTF-8 string<br/>
		/// </summary>
		public static void AddInputCharactersUTF8(ref ImGuiIO self, byte* str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				AddInputCharactersUTF8Native((ImGuiIO*)pself, str);
			}
		}

		/// <summary>
		/// Queue a new characters input from a UTF-8 string<br/>
		/// </summary>
		public static void AddInputCharactersUTF8(ImGuiIOPtr self, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				AddInputCharactersUTF8Native(self, (byte*)pstr);
			}
		}

		/// <summary>
		/// Queue a new characters input from a UTF-8 string<br/>
		/// </summary>
		public static void AddInputCharactersUTF8(ImGuiIOPtr self, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				AddInputCharactersUTF8Native(self, (byte*)pstr);
			}
		}

		/// <summary>
		/// Queue a new characters input from a UTF-8 string<br/>
		/// </summary>
		public static void AddInputCharactersUTF8(ImGuiIOPtr self, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			AddInputCharactersUTF8Native(self, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Queue a new characters input from a UTF-8 string<br/>
		/// </summary>
		public static void AddInputCharactersUTF8(ref ImGuiIO self, ref byte str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				fixed (byte* pstr = &str)
				{
					AddInputCharactersUTF8Native((ImGuiIO*)pself, (byte*)pstr);
				}
			}
		}

		/// <summary>
		/// Queue a new characters input from a UTF-8 string<br/>
		/// </summary>
		public static void AddInputCharactersUTF8(ref ImGuiIO self, ReadOnlySpan<byte> str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				fixed (byte* pstr = str)
				{
					AddInputCharactersUTF8Native((ImGuiIO*)pself, (byte*)pstr);
				}
			}
		}

		/// <summary>
		/// Queue a new characters input from a UTF-8 string<br/>
		/// </summary>
		public static void AddInputCharactersUTF8(ref ImGuiIO self, string str)
		{
			fixed (ImGuiIO* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				AddInputCharactersUTF8Native((ImGuiIO*)pself, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// [Optional] Specify index for legacy &lt;1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetKeyEventNativeDataNative(ImGuiIO* self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, ImGuiKey, int, int, int, void>)funcTable[436])(self, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
			#else
			((delegate* unmanaged[Cdecl]<nint, ImGuiKey, int, int, int, void>)funcTable[436])((nint)self, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
			#endif
		}

		/// <summary>
		/// [Optional] Specify index for legacy &lt;1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.<br/>
		/// </summary>
		public static void SetKeyEventNativeData(ImGuiIOPtr self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			SetKeyEventNativeDataNative(self, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
		}

		/// <summary>
		/// [Optional] Specify index for legacy &lt;1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.<br/>
		/// </summary>
		public static void SetKeyEventNativeData(ImGuiIOPtr self, ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			SetKeyEventNativeDataNative(self, key, nativeKeycode, nativeScancode, (int)(-1));
		}

		/// <summary>
		/// [Optional] Specify index for legacy &lt;1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.<br/>
		/// </summary>
		public static void SetKeyEventNativeData(ref ImGuiIO self, ImGuiKey key, int nativeKeycode, int nativeScancode, int nativeLegacyIndex)
		{
			fixed (ImGuiIO* pself = &self)
			{
				SetKeyEventNativeDataNative((ImGuiIO*)pself, key, nativeKeycode, nativeScancode, nativeLegacyIndex);
			}
		}

		/// <summary>
		/// [Optional] Specify index for legacy &lt;1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.<br/>
		/// </summary>
		public static void SetKeyEventNativeData(ref ImGuiIO self, ImGuiKey key, int nativeKeycode, int nativeScancode)
		{
			fixed (ImGuiIO* pself = &self)
			{
				SetKeyEventNativeDataNative((ImGuiIO*)pself, key, nativeKeycode, nativeScancode, (int)(-1));
			}
		}

		/// <summary>
		/// Set master flag for accepting keymousetext events (default to true). Useful if you have native dialog boxes that are interrupting your application looprefresh, and you want to disable events being queued while your app is frozen.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetAppAcceptingEventsNative(ImGuiIO* self, byte acceptingEvents)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, byte, void>)funcTable[437])(self, acceptingEvents);
			#else
			((delegate* unmanaged[Cdecl]<nint, byte, void>)funcTable[437])((nint)self, acceptingEvents);
			#endif
		}

		/// <summary>
		/// Set master flag for accepting keymousetext events (default to true). Useful if you have native dialog boxes that are interrupting your application looprefresh, and you want to disable events being queued while your app is frozen.<br/>
		/// </summary>
		public static void SetAppAcceptingEvents(ImGuiIOPtr self, bool acceptingEvents)
		{
			SetAppAcceptingEventsNative(self, acceptingEvents ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Set master flag for accepting keymousetext events (default to true). Useful if you have native dialog boxes that are interrupting your application looprefresh, and you want to disable events being queued while your app is frozen.<br/>
		/// </summary>
		public static void SetAppAcceptingEvents(ref ImGuiIO self, bool acceptingEvents)
		{
			fixed (ImGuiIO* pself = &self)
			{
				SetAppAcceptingEventsNative((ImGuiIO*)pself, acceptingEvents ? (byte)1 : (byte)0);
			}
		}

		/// <summary>
		/// Clear all incoming events.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearEventsQueueNative(ImGuiIO* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, void>)funcTable[438])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[438])((nint)self);
			#endif
		}

		/// <summary>
		/// Clear all incoming events.<br/>
		/// </summary>
		public static void ClearEventsQueue(ImGuiIOPtr self)
		{
			ClearEventsQueueNative(self);
		}

		/// <summary>
		/// Clear all incoming events.<br/>
		/// </summary>
		public static void ClearEventsQueue(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ClearEventsQueueNative((ImGuiIO*)pself);
			}
		}

		/// <summary>
		/// Clear current keyboardgamepad state + current frame text input buffer. Equivalent to releasing all keysbuttons.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearInputKeysNative(ImGuiIO* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, void>)funcTable[439])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[439])((nint)self);
			#endif
		}

		/// <summary>
		/// Clear current keyboardgamepad state + current frame text input buffer. Equivalent to releasing all keysbuttons.<br/>
		/// </summary>
		public static void ClearInputKeys(ImGuiIOPtr self)
		{
			ClearInputKeysNative(self);
		}

		/// <summary>
		/// Clear current keyboardgamepad state + current frame text input buffer. Equivalent to releasing all keysbuttons.<br/>
		/// </summary>
		public static void ClearInputKeys(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ClearInputKeysNative((ImGuiIO*)pself);
			}
		}

		/// <summary>
		/// Clear current mouse state.<br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearInputMouseNative(ImGuiIO* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, void>)funcTable[440])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[440])((nint)self);
			#endif
		}

		/// <summary>
		/// Clear current mouse state.<br/>
		/// </summary>
		public static void ClearInputMouse(ImGuiIOPtr self)
		{
			ClearInputMouseNative(self);
		}

		/// <summary>
		/// Clear current mouse state.<br/>
		/// </summary>
		public static void ClearInputMouse(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				ClearInputMouseNative((ImGuiIO*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiIO* ImGuiIONative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiIO*>)funcTable[441])();
			#else
			return (ImGuiIO*)((delegate* unmanaged[Cdecl]<nint>)funcTable[441])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiIOPtr ImGuiIO()
		{
			ImGuiIOPtr ret = ImGuiIONative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiIO* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiIO*, void>)funcTable[442])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[442])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiIOPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiIO self)
		{
			fixed (ImGuiIO* pself = &self)
			{
				DestroyNative((ImGuiIO*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImGuiInputTextCallbackData* ImGuiInputTextCallbackDataNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*>)funcTable[443])();
			#else
			return (ImGuiInputTextCallbackData*)((delegate* unmanaged[Cdecl]<nint>)funcTable[443])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImGuiInputTextCallbackDataPtr ImGuiInputTextCallbackData()
		{
			ImGuiInputTextCallbackDataPtr ret = ImGuiInputTextCallbackDataNative();
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyNative(ImGuiInputTextCallbackData* self)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, void>)funcTable[444])(self);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[444])((nint)self);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ImGuiInputTextCallbackDataPtr self)
		{
			DestroyNative(self);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void Destroy(ref ImGuiInputTextCallbackData self)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				DestroyNative((ImGuiInputTextCallbackData*)pself);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteCharsNative(ImGuiInputTextCallbackData* self, int pos, int bytesCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int, int, void>)funcTable[445])(self, pos, bytesCount);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[445])((nint)self, pos, bytesCount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DeleteChars(ImGuiInputTextCallbackDataPtr self, int pos, int bytesCount)
		{
			DeleteCharsNative(self, pos, bytesCount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void DeleteChars(ref ImGuiInputTextCallbackData self, int pos, int bytesCount)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				DeleteCharsNative((ImGuiInputTextCallbackData*)pself, pos, bytesCount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InsertCharsNative(ImGuiInputTextCallbackData* self, int pos, byte* text, byte* textEnd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ImGuiInputTextCallbackData*, int, byte*, byte*, void>)funcTable[446])(self, pos, text, textEnd);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[446])((nint)self, pos, (nint)text, (nint)textEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, byte* text, byte* textEnd)
		{
			InsertCharsNative(self, pos, text, textEnd);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, byte* text)
		{
			InsertCharsNative(self, pos, text, (byte*)(default));
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, text, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, text, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, ref byte text, byte* textEnd)
		{
			fixed (byte* ptext = &text)
			{
				InsertCharsNative(self, pos, (byte*)ptext, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, ref byte text)
		{
			fixed (byte* ptext = &text)
			{
				InsertCharsNative(self, pos, (byte*)ptext, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, ReadOnlySpan<byte> text, byte* textEnd)
		{
			fixed (byte* ptext = text)
			{
				InsertCharsNative(self, pos, (byte*)ptext, textEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, ReadOnlySpan<byte> text)
		{
			fixed (byte* ptext = text)
			{
				InsertCharsNative(self, pos, (byte*)ptext, (byte*)(default));
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, string text, byte* textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertCharsNative(self, pos, pStr0, textEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, string text)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertCharsNative(self, pos, pStr0, (byte*)(default));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ref byte text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ref byte text)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ReadOnlySpan<byte> text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = text)
				{
					InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, textEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ReadOnlySpan<byte> text)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = text)
				{
					InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, (byte*)(default));
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, string text, byte* textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, pStr0, textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, string text)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (text != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(text);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, pStr0, (byte*)(default));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, byte* text, ref byte textEnd)
		{
			fixed (byte* ptextEnd = &textEnd)
			{
				InsertCharsNative(self, pos, text, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, byte* text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptextEnd = textEnd)
			{
				InsertCharsNative(self, pos, text, (byte*)ptextEnd);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, byte* text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (textEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertCharsNative(self, pos, text, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, text, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text, ReadOnlySpan<byte> textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, text, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, byte* text, string textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, text, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, ref byte text, ref byte textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					InsertCharsNative(self, pos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, ReadOnlySpan<byte> text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					InsertCharsNative(self, pos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, string text, string textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (textEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(textEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(textEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			InsertCharsNative(self, pos, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, ref byte text, ReadOnlySpan<byte> textEnd)
		{
			fixed (byte* ptext = &text)
			{
				fixed (byte* ptextEnd = textEnd)
				{
					InsertCharsNative(self, pos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, ref byte text, string textEnd)
		{
			fixed (byte* ptext = &text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertCharsNative(self, pos, (byte*)ptext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, ReadOnlySpan<byte> text, ref byte textEnd)
		{
			fixed (byte* ptext = text)
			{
				fixed (byte* ptextEnd = &textEnd)
				{
					InsertCharsNative(self, pos, (byte*)ptext, (byte*)ptextEnd);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, ReadOnlySpan<byte> text, string textEnd)
		{
			fixed (byte* ptext = text)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (textEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(textEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(textEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				InsertCharsNative(self, pos, (byte*)ptext, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, string text, ref byte textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = &textEnd)
			{
				InsertCharsNative(self, pos, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ImGuiInputTextCallbackDataPtr self, int pos, string text, ReadOnlySpan<byte> textEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (text != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(text);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(text, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* ptextEnd = textEnd)
			{
				InsertCharsNative(self, pos, pStr0, (byte*)ptextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void InsertChars(ref ImGuiInputTextCallbackData self, int pos, ref byte text, ref byte textEnd)
		{
			fixed (ImGuiInputTextCallbackData* pself = &self)
			{
				fixed (byte* ptext = &text)
				{
					fixed (byte* ptextEnd = &textEnd)
					{
						InsertCharsNative((ImGuiInputTextCallbackData*)pself, pos, (byte*)ptext, (byte*)ptextEnd);
					}
				}
			}
		}
	}
}
